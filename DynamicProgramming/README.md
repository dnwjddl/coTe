# Dynamic Programming
- 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 계산하지 않음
- 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식(Top-down 과 Bottom-up) 으로 구성


- 다이나믹 프로그래밍은 **동적계획법** 이라고 부름
- Dynamic이란?
  - 자료구조에서 동적 할당(Dynamic Allocation)은 **프로그램이 실행되는 도중에 실행에 필요한 메로리를 할당하는 기법**을 의미

### 다이나믹 프로그래밍의 조건
- 최적 부분 구조(Optimal Substructure)
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
- 중복되는 부분 문제(Overlapping Subproblem)
  - 동일한 작은 문제를 반복적으로 해결해야 함


## 피보나치 수열
```python
def fibo(x):
  if x == 1 or x==2:
    return 1
  return fibo(x-1) + fibo(x-2)
print(fibo(4))
```

- 피보나치 수열은 중복될 수 있음 (fibo(2)등이 반복: 저장해놔야 복잡도가 적어짐)
- 기존 피보나치 수열은 O(N^2)
- **다이나믹 프로그래밍**을 통해서 해결 가능

## 메모이제이션(Memoization) > 하향식
- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
- 한번 계산한 결과를 메모리 공간에 메모하는 기법
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
  - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 함

## Top-down & Bottom-Up
- Top-down(메모제이션): 하향식
- Bottom-up: 상향식
- 다이나믹 프로그래밍의 전형적인 형태는 Bottom-up 방식임
  - 결과 저장용 리스트는 DP 테이블이라고부름
- 메모제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님
  - 한번 계산된 결과를 담아놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음
  - 메모이제이션을 사용했다 = 캐시를 사용했다


```python
# Top-down 다이나믹 프로그래밍
d = [0] * 100
def fibo(x):
  if x == 1 or x==2:
    return 1
  if d[x] != 0:
    return d[x]
  d[x] = fibo(x-1) + fibo(x-2)
  return d[x]

# bottom-up 다이나믹 프로그래밍
d = [0] * 100
d[1] =1
d[2] =1
n = 99
for i in range(3, n+1):
  d[i] = d[i-1] + d[i-2]
```

## 다이나믹 프로그래밍 문제 접근 방법
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어를 떠올려줌
  - 이때, 이들의 문제가지고만 수행할 수 없을 때 다이나믹프로그래밍 알고리즘을 고려해줌



### 문제
1. 개미전사
창고 바로 옆은 안되고 건너뛰어서 창고에서 가장 최대를 만들어야됨   
=> max(```앞위치까지의 최적의 해``` ,```그 둘 앞의 최적의 해```  + 나)  

```python
d = [0] * 100
d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2, n):
  d[i] = max(d[i-1], d[i-2] + array[i])
```

2. 1로 만들기
5로 나뉘어지면 5로 나누고, 3으로 나뉘어지면 3으로 나누고, 2로 나뉘어지면 2로 나누고 1을 뺌 네가지 방법 중 최소한으로 사용하여 1로 만들기    
- 트리로 만들어보면 3개로 나뉘어져서 트리를 길게 늘어놓을 수 있음, 높이가 높을수록 안좋은거  
=> min(ai-1, ai/2, ai/3, ai/5) + 1

```python
d= [0] * 30001
for i in range(2, x+1):
  d[i] = d[i-1] +1
  if i%2 == 0:
    d[i] = min(d[i],d[i//2] + 1)
  if i%3 == 0:
    d[i] = min(d[i], d[i//3] +1)
  if i%5 == 0:
    d[i] = min(d[i], d[i//5] +1)
```



## 정리
- Top-Down 방식: 이미 수행한 결과를 저장하는 메모제이션
- Bottom-Up 방식: DP 테이블
- Top-Down 방식을 사용할때는 사전 자료형을 사용할 수 도 있음
  - 수열처럼 연속적이지 않은 자료가 주어졌을때 유용
- Bottom-UP 방식으로 다이나믹 프로그래밍을 하라고 권장함
- 만약 재귀함수를 사용하는 Top-Down 방식을 계속 사용하다보면 재귀횟수 제한에 대한 오류가 걸릴 수도 있기 때문임
 - sys 라이브러리의 setrecursionlimit() 메서드를 호풀하면 재귀 제한 횟수를 늘려줄 수 있긴 함
