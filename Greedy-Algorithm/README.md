# Greedy-Algorithm

**현재 상황에서 지금 당장 좋은 것만 고르는 방법**
- 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
  - ```크루스칼 알고리즘``` & ```다익스트라 알고리즘``` 등 잘알려진 알고리즘 제외
- 그리디해법은 **정당성 분석**이 중요
  - 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토

---

Q. 루트 노드부터 시작하여 거쳐가는 노드의 합을 최대로 만들고 싶다
![image](https://user-images.githubusercontent.com/72767245/129600868-44a238f4-ed07-49e2-83ce-8a491c2b0ccc.png)

- (최적) 5 + 7 + 9 = 21
- (그리디) 5 + 10 + 4 = 19 


---

- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다
- 하지만, 코딩테스트에서의 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론**할 수 있어야 풀리도록 출제

---


ex) 거스름돈 문제: 가장 큰 화페부터 돈을 거슬러주면 됨
- 그리디 알고리즘이 통하는 이유:
  - 큰 단위가 작은 단위의 배수이기 때문
  - 만약 동전이 500원, 400원, 100원 이였으면 800원을 거슬러줘야될때 500+100+100+100 보단 400+400이 나음

ex) 1이 될때까지: N에서 1을 빼거나 K로 나누거나 과정의 갯수 최소한으로
- 주어진 N에 대해서 최대한 나누어주기
- 성립할 수 있는 이유) N의 값을 줄일때 2이상의 수를 나누는 작업이 1을 뺴는 작업보다 수를 훨씬 많이 줄일 수 있음 

---


## 구현
구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정  
풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제  

- 알고리즘은 간단하지만 코드가 지나칠 만큼 길어짐
- 실수 연산을 다루고 특정 소수점 자리까지 출력해야됨
- 문자열을 특정한 기준에 따라서 끊어 처리해야됨
- 적절한 라이브러리를 찾아서 사용해야 하는 문제

1. **행렬(Matrix)**많이 사용함  
2. **방향벡터** 많이 사용
  - 시뮬레이션 및 완전탐색 문제에서는 2차원 공간에서의 방향벡터 많이 사용
```python
# 동, 북, 서, 남
# 오른, 위, 왼, 아래
dx = [0,-1,0,1]
dy = [1,0,-1,0]

# 현재위치
x , y = 2,2

for i in range(4):
  #다음위치
  nx = x + dx[i]
  ny = y + dy[i]
  print(nx, ny)
```

---

ex)

```python
# 초기값
x, y = 1,1
plans = input().split()

# L, R, U, D에 따른 이동방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

for plan in plans:
  # 이동 후 좌표 구하기
  for i in range(len(move_types)):
    if plan == move_types[i]:
      nx = x+ dx[i]
      ny = y+ dy[i]
  # 공간을 벗어나는 경우 무시
  if nx<1 or ny <1 or nx > x or ny > n:
    continue
  x, y = nx, ny

print(x, y)
```
